<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <!-- <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?571c3612023b230e8c1243489bf880cb";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script> -->
    <meta name="description" content="English introductionPlease view README-EN.md  用React、Redux、Immutable做俄罗斯方块 俄罗斯方块是一直各类程序语言热衷实现的经典游戏，JavaScript的实现版本也有很多，用React 做好俄罗斯方块则成了我一个目标。 戳：https:&#x2F;&#x2F;chvin.github.io&#x2F;react-tetris&#x2F; 玩一玩！  效果预览 正常速度的录">
<meta property="og:type" content="website">
<meta property="og:title" content="VestJin">
<meta property="og:url" content="http://jinmajue.site/games/react-tetris-master/README.html">
<meta property="og:site_name" content="VestJin">
<meta property="og:description" content="English introductionPlease view README-EN.md  用React、Redux、Immutable做俄罗斯方块 俄罗斯方块是一直各类程序语言热衷实现的经典游戏，JavaScript的实现版本也有很多，用React 做好俄罗斯方块则成了我一个目标。 戳：https:&#x2F;&#x2F;chvin.github.io&#x2F;react-tetris&#x2F; 玩一玩！  效果预览 正常速度的录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.alicdn.com/tps/TB1Ag7CNXXXXXaoXXXXXXXXXXXX-320-483.gif">
<meta property="og:image" content="https://img.alicdn.com/tps/TB1AdjZNXXXXXcCapXXXXXXXXXX-480-343.gif">
<meta property="og:image" content="https://img.alicdn.com/tps/TB1kvJyOVXXXXbhaFXXXXXXXXXX-320-555.gif">
<meta property="og:image" content="https://img.alicdn.com/tps/TB1EY7cNXXXXXXraXXXXXXXXXXX-320-399.gif">
<meta property="og:image" content="https://img.alicdn.com/tps/TB1hGQqNXXXXXX3XFXXXXXXXXXX-640-381.gif">
<meta property="og:image" content="https://img.alicdn.com/tps/TB1fYgzNXXXXXXnXpXXXXXXXXXX-633-358.png">
<meta property="og:image" content="https://img.alicdn.com/tps/TB1nBf1NXXXXXagapXXXXXXXXXX-520-371.png">
<meta property="og:image" content="https://img.alicdn.com/tps/TB15z4VOVXXXXahaXXXXXXXXXXX-679-133.png">
<meta property="og:image" content="https://img.alicdn.com/tps/TB1qq7kNXXXXXacXFXXXXXXXXXX-400-186.png">
<meta property="og:image" content="https://img.alicdn.com/tfs/TB1B6ODRXXXXXXHaFXXXXXXXXXX-1920-1080.png">
<meta property="article:published_time" content="2024-09-23T00:58:46.171Z">
<meta property="article:modified_time" content="2019-05-13T10:55:36.000Z">
<meta property="article:author" content="VestJin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.alicdn.com/tps/TB1Ag7CNXXXXXaoXXXXXXXXXXXX-320-483.gif">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>VestJin</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	

    

<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">VestJin</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/search/">搜索</a></li><!--
   --><!--
     --><li><a href="/categories/">分类</a></li><!--
   --><!--
     --><li><a href="/games/">Games</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/vestjin">项目</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <h3 id="English-introduction"><a href="#English-introduction" class="headerlink" title="English introduction"></a>English introduction</h3><p>Please view <a target="_blank" rel="noopener" href="https://github.com/chvin/react-tetris/blob/master/README-EN.md">README-EN.md</a></p>
<hr>
<h2 id="用React、Redux、Immutable做俄罗斯方块"><a href="#用React、Redux、Immutable做俄罗斯方块" class="headerlink" title="用React、Redux、Immutable做俄罗斯方块"></a>用React、Redux、Immutable做俄罗斯方块</h2><hr>
<p>俄罗斯方块是一直各类程序语言热衷实现的经典游戏，JavaScript的实现版本也有很多，用React 做好俄罗斯方块则成了我一个目标。</p>
<p>戳：<a target="_blank" rel="noopener" href="https://chvin.github.io/react-tetris/">https://chvin.github.io/react-tetris/</a> 玩一玩！</p>
<hr>
<h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p><img src="https://img.alicdn.com/tps/TB1Ag7CNXXXXXaoXXXXXXXXXXXX-320-483.gif" alt="效果预览"></p>
<p>正常速度的录制，体验流畅。</p>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p><img src="https://img.alicdn.com/tps/TB1AdjZNXXXXXcCapXXXXXXXXXX-480-343.gif" alt="响应式"></p>
<p>不仅指屏幕的自适应，而是<code>在PC使用键盘、在手机使用手指的响应式操作</code>：</p>
<p><img src="https://img.alicdn.com/tps/TB1kvJyOVXXXXbhaFXXXXXXXXXX-320-555.gif" alt="手机"></p>
<h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p><img src="https://img.alicdn.com/tps/TB1EY7cNXXXXXXraXXXXXXXXXXX-320-399.gif" alt="数据持久化"></p>
<p>玩单机游戏最怕什么？断电。通过订阅 <code>store.subscribe</code>，将state储存在localStorage，精确记录所有状态。网页关了刷新了、程序崩溃了、手机没电了，重新打开连接，都可以继续。</p>
<h3 id="Redux-状态预览（Redux-DevTools-extension）"><a href="#Redux-状态预览（Redux-DevTools-extension）" class="headerlink" title="Redux 状态预览（Redux DevTools extension）"></a>Redux 状态预览（<a target="_blank" rel="noopener" href="https://github.com/zalmoxisus/redux-devtools-extension">Redux DevTools extension</a>）</h3><p><img src="https://img.alicdn.com/tps/TB1hGQqNXXXXXX3XFXXXXXXXXXX-640-381.gif" alt="Redux状态预览"></p>
<p>Redux设计管理了所有应存的状态，这是上面持久化的保证。</p>
<hr>
<p>游戏框架使用的是 React + Redux，其中再加入了 Immutable，用它的实例来做来Redux的state。（有关React和Redux的介绍可以看：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/03/react.html">React入门实例</a>、<a target="_blank" rel="noopener" href="https://camsong.github.io/redux-in-chinese/index.html">Redux中文文档</a>）</p>
<h2 id="1、什么是-Immutable？"><a href="#1、什么是-Immutable？" class="headerlink" title="1、什么是 Immutable？"></a>1、什么是 Immutable？</h2><p>Immutable 是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。</p>
<h3 id="初识："><a href="#初识：" class="headerlink" title="初识："></a>初识：</h3><p>让我们看下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">keyLog</span>(<span class="hljs-params">touchFn</span>) &#123;<br>  <span class="hljs-keyword">let</span> data = &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;;<br>  <span class="hljs-title function_">f</span>(data);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">key</span>); <span class="hljs-comment">// 猜猜会打印什么？</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>不查看f，不知道它对 <code>data</code> 做了什么，无法确认会打印什么。但如果 <code>data</code> 是 Immutable，你可以确定打印的是 <code>value</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">keyLog</span>(<span class="hljs-params">touchFn</span>) &#123;<br>  <span class="hljs-keyword">let</span> data = <span class="hljs-title class_">Immutable</span>.<span class="hljs-title class_">Map</span>(&#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;);<br>  <span class="hljs-title function_">f</span>(data);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;key&#x27;</span>));  <span class="hljs-comment">// value</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>JavaScript 中的<code>Object</code>与<code>Array</code>等使用的是引用赋值，新的对象简单的引用了原始对象，改变新也将影响旧的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">foo = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;  bar = foo;  bar.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br>foo.<span class="hljs-property">a</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>
<p>虽然这样做可以节约内存，但当应用复杂后，造成了状态不可控，是很大的隐患，节约的内存优点变得得不偿失。</p>
<p>Immutable则不一样，相应的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">foo = <span class="hljs-title class_">Immutable</span>.<span class="hljs-title class_">Map</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;);  bar = foo.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>);<br>foo.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<h3 id="简洁："><a href="#简洁：" class="headerlink" title="简洁："></a>简洁：</h3><p>在<code>Redux</code>中，它的最优做法是每个<code>reducer</code>都返回一个新的对象（数组），所以我们常常会看到这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// reducer</span><br>...<br><span class="hljs-keyword">return</span> [<br>   ...oldArr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>),<br>   newValue,<br>   ...oldArr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">4</span>)<br>];<br></code></pre></td></tr></table></figure>
<p>为了返回新的对象（数组），不得不有上面奇怪的样子，而在使用更深的数据结构时会变的更棘手。<br>让我们看看Immutable的做法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// reducer</span><br>...<br><span class="hljs-keyword">return</span> oldArr.<span class="hljs-title function_">set</span>(<span class="hljs-number">4</span>, newValue);<br></code></pre></td></tr></table></figure>
<p>是不是很简洁？</p>
<h3 id="关于-“-”："><a href="#关于-“-”：" class="headerlink" title="关于 “&#x3D;&#x3D;&#x3D;”："></a>关于 “&#x3D;&#x3D;&#x3D;”：</h3><p>我们知道对于<code>Object</code>与<code>Array</code>的<code>===</code>比较，是对引用地址的比较而不是“值比较”，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">c</span>:<span class="hljs-number">3</span>&#125; === &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">c</span>:<span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// false</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]] === [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>对于上面只能采用 <code>deepCopy</code>、<code>deepCompare</code>来遍历比较，不仅麻烦且好性能。</p>
<p>我们感受来一下<code>Immutable</code>的做法！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">map1 = <span class="hljs-title class_">Immutable</span>.<span class="hljs-title class_">Map</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">c</span>:<span class="hljs-number">3</span>&#125;);<br>map2 = <span class="hljs-title class_">Immutable</span>.<span class="hljs-title class_">Map</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">c</span>:<span class="hljs-number">3</span>&#125;);<br><span class="hljs-title class_">Immutable</span>.<span class="hljs-title function_">is</span>(map1, map2); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// List1 = Immutable.List([1, 2, Immutable.List[3, 4]]);</span><br><span class="hljs-title class_">List1</span> = <span class="hljs-title class_">Immutable</span>.<span class="hljs-title function_">fromJS</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]);<br><span class="hljs-title class_">List2</span> = <span class="hljs-title class_">Immutable</span>.<span class="hljs-title function_">fromJS</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]);<br><span class="hljs-title class_">Immutable</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">List1</span>, <span class="hljs-title class_">List2</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>似乎有阵清风吹过。</p>
<p>React 做性能优化时有一个<code>大招</code>，就是使用 <code>shouldComponentUpdate()</code>，但它默认返回 <code>true</code>，即始终会执行 <code>render()</code> 方法，后面做 Virtual DOM 比较。</p>
<p>在使用原生属性时，为了得出shouldComponentUpdate正确的<code>true</code> or <code>false</code>，不得不用deepCopy、deepCompare来算出答案，消耗的性能很不划算。而在有了Immutable之后，使用上面的方法对深层结构的比较就变的易如反掌。</p>
<p>对于「俄罗斯方块」，试想棋盘是一个<code>二维数组</code>，可以移动的方块则是<code>形状(也是二维数组)</code>+<code>坐标</code>。棋盘与方块的叠加则组成了最后的结果<code>Matrix</code>。游戏中上面的属性都由<code>Immutable</code>构建，通过它的比较方法，可以轻松写好<code>shouldComponentUpdate</code>。源代码：<a target="_blank" rel="noopener" href="https://github.com/chvin/react-tetris/blob/master/src/components/matrix/index.js#L35">&#x2F;src&#x2F;components&#x2F;matrix&#x2F;index.js#L35</a></p>
<p>Immutable学习资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://facebook.github.io/immutable-js/">Immutable.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/camsong/blog/issues/3">Immutable 详解及 React 中实践</a></li>
</ul>
<hr>
<h2 id="2、如何在Redux中使用Immutable"><a href="#2、如何在Redux中使用Immutable" class="headerlink" title="2、如何在Redux中使用Immutable"></a>2、如何在Redux中使用Immutable</h2><p>目标：将<code>state</code> -&gt; Immutable化。<br>关键的库：<a target="_blank" rel="noopener" href="https://github.com/gajus/redux-immutable">gajus&#x2F;redux-immutable</a><br>将原来 Redux提供的combineReducers改由上面的库提供：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// rootReducers.js</span><br><span class="hljs-comment">// import &#123; combineReducers &#125; from &#x27;redux&#x27;; // 旧的方法</span><br><span class="hljs-keyword">import</span> &#123; combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-immutable&#x27;</span>; <span class="hljs-comment">// 新的方法</span><br><br><span class="hljs-keyword">import</span> prop1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./prop1&#x27;</span>;<br><span class="hljs-keyword">import</span> prop2 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./prop2&#x27;</span>;<br><span class="hljs-keyword">import</span> prop3 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./prop3&#x27;</span>;<br><br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-title function_">combineReducers</span>(&#123;<br>  prop1, prop2, prop3,<br>&#125;);<br><br><br><span class="hljs-comment">// store.js</span><br><span class="hljs-comment">// 创建store的方法和常规一样</span><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> rootReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducers&#x27;</span>;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure>
<p>通过新的<code>combineReducers</code>将把store对象转化成Immutable，在container中使用时也会略有不同（但这正是我们想要的）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapStateToProps</span> = (<span class="hljs-params">state</span>) =&gt; (&#123;<br>  <span class="hljs-attr">prop1</span>: state.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;prop1&#x27;</span>),<br>  <span class="hljs-attr">prop2</span>: state.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;prop2&#x27;</span>),<br>  <span class="hljs-attr">prop3</span>: state.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;prop3&#x27;</span>),<br>  <span class="hljs-attr">next</span>: state.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;next&#x27;</span>),<br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">connect</span>(mapStateToProps)(<span class="hljs-title class_">App</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="3、Web-Audio-Api"><a href="#3、Web-Audio-Api" class="headerlink" title="3、Web Audio Api"></a>3、Web Audio Api</h2><p>游戏里有很多不同的音效，而实际上只引用了一个音效文件：<a target="_blank" rel="noopener" href="https://github.com/chvin/react-tetris/blob/master/build/music.mp3">&#x2F;build&#x2F;music.mp3</a>。借助<code>Web Audio Api</code>能够以毫秒级精确、高频率的播放音效，这是<code>&lt;audio&gt;</code>标签所做不到的。在游戏进行中按住方向键移动方块，便可以听到高频率的音效。</p>
<p><img src="https://img.alicdn.com/tps/TB1fYgzNXXXXXXnXpXXXXXXXXXX-633-358.png" alt="网页音效进阶"></p>
<p><code>WAA</code> 是一套全新的相对独立的接口系统，对音频文件拥有更高的处理权限以及更专业的内置音频效果，是W3C的推荐接口，能专业处理“音速、音量、环境、音色可视化、高频、音向”等需求，下图介绍了WAA的使用流程。</p>
<p><img src="https://img.alicdn.com/tps/TB1nBf1NXXXXXagapXXXXXXXXXX-520-371.png" alt="流程"></p>
<p>其中Source代表一个音频源，Destination代表最终的输出，多个Source合成出了Destination。<br>源代码：<a target="_blank" rel="noopener" href="https://github.com/chvin/react-tetris/blob/master/src/unit/music.js">&#x2F;src&#x2F;unit&#x2F;music.js</a> 实现了ajax加载mp3，并转为WAA，控制播放的过程。</p>
<p><code>WAA</code> 在各个浏览器的最新2个版本下的支持情况（<a target="_blank" rel="noopener" href="http://caniuse.com/#search=webaudio">CanIUse</a>）</p>
<p><img src="https://img.alicdn.com/tps/TB15z4VOVXXXXahaXXXXXXXXXXX-679-133.png" alt="浏览器兼容"></p>
<p>可以看到IE阵营与大部分安卓机不能使用，其他ok。</p>
<p>Web Audio Api 学习资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API">Web API 接口| MDN</a></li>
<li><a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/webaudio/intro/">Getting Started with Web Audio API</a></li>
</ul>
<hr>
<h2 id="4、游戏在体验上的优化"><a href="#4、游戏在体验上的优化" class="headerlink" title="4、游戏在体验上的优化"></a>4、游戏在体验上的优化</h2><ul>
<li>技术：<ul>
<li>按下方向键水平移动和竖直移动的触发频率是不同的，游戏可以定义触发频率，代替原生的事件频率，源代码：<a target="_blank" rel="noopener" href="https://github.com/chvin/react-tetris/blob/master/src/unit/event.js">&#x2F;src&#x2F;unit&#x2F;event.js</a> ；</li>
<li>左右移动可以 delay 掉落的速度，但在撞墙移动的时候 delay 的稍小；在速度为6级时 通过delay 会保证在一行内水平完整移动一次；</li>
<li>对按钮同时注册<code>touchstart</code>和<code>mousedown</code>事件，以供响应式游戏。当<code>touchstart</code>发生时，不会触发<code>mousedown</code>，而当<code>mousedown</code>发生时，由于鼠标移开事件元素可以不触发<code>mouseup</code>，将同时监听<code>mouseout</code> 模拟 <code>mouseup</code>。源代码：<a target="_blank" rel="noopener" href="https://github.com/chvin/react-tetris/blob/master/src/components/keyboard/index.js">&#x2F;src&#x2F;components&#x2F;keyboard&#x2F;index.js</a>；</li>
<li>监听了 <code>visibilitychange</code> 事件，当页面被隐藏\切换的时候，游戏将不会进行，切换回来将继续，这个<code>focus</code>状态也被写进了Redux中。所以当用手机玩来<code>电话</code>时，游戏进度将保存；PC开着游戏干别的也不会听到gameover，这有点像 <code>ios</code> 应用的切换。</li>
<li>在<code>任意</code>时刻刷新网页，（比如消除方块时、游戏结束时）也能还原当前状态；</li>
<li>游戏中唯一用到的图片是<img src="https://img.alicdn.com/tps/TB1qq7kNXXXXXacXFXXXXXXXXXX-400-186.png" alt="image">，其他都是CSS；</li>
<li>游戏兼容 Chrome、Firefox、IE9+、Edge等；</li>
</ul>
</li>
<li>玩法：<ul>
<li>可以在游戏未开始时制定初始的棋盘（十个级别）和速度（六个级别）；</li>
<li>一次消除1行得100分、2行得300分、3行得700分、4行得1500分；</li>
<li>方块掉落速度会随着消除的行数增加（每20行增加一个级别）；</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5、开发中的经验梳理"><a href="#5、开发中的经验梳理" class="headerlink" title="5、开发中的经验梳理"></a>5、开发中的经验梳理</h2><ul>
<li>为所有的<code>component</code>都编写了<code>shouldComponentUpdate</code>，在手机上的性能相对有显著的提升。中大型应用在遇到性能上的问题的时候，写好shouldComponentUpdate 一定会帮你一把。</li>
<li><code>无状态组件</code>（<a target="_blank" rel="noopener" href="https://medium.com/@joshblack/stateless-components-in-react-0-14-f9798f8b992d#.xjqnbfx4e">Stateless Functional Components</a>）是没有生命周期的。而因为上条因素，所有组件都需要生命周期 shouldComponentUpdate，所以未使用无状态组件。</li>
<li>在 <code>webpack.config.js</code> 中的 devServer属性写入<code>host: &#39;0.0.0.0&#39;</code>，可以在开发时用ip访问，不局限在localhost；</li>
<li>redux中的<code>store</code>并非只能通过connect将方法传递给<code>container</code>，可以跳出组件，在别的文件拿出来做流程控制(dispatch)，源代码：<a target="_blank" rel="noopener" href="https://github.com/chvin/react-tetris/blob/master/src/control/states.js">&#x2F;src&#x2F;control&#x2F;states.js</a>；</li>
<li>用 react+redux 做持久化非常的方便，只要将redux状态储存，在每一个reduers做初始化的时候读取就好。</li>
<li>通过配置 .eslintrc.js<code> 与 webpack.config.js</code> ，项目中集成了 <code>ESLint</code> 检验。使用 ESLint 可以使编码按规范编写，有效地控制代码质量。不符规范的代码在开发时（或build时）都能通过IDE与控制台发现错误。 参考：<a target="_blank" rel="noopener" href="https://github.com/dwqs/react-style-guide">Airbnb: React使用规范</a>；</li>
</ul>
<hr>
<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><ul>
<li>作为一个 React 的练手应用，在实现的过程中发现小小的“方块”还是有很多的细节可以优化和打磨，这时就是考验一名前端工程师的细心和功力的时候。</li>
<li>优化的方向既有 React 的本身，比如哪些状态由 Redux存，哪些状态给组件的state就好；而跳出框架又有产品的很多特点可以玩，为了达到你的需求，这些都将自然的推进技术的发展。</li>
<li>一个项目从零开始，功能一点一滴慢慢累积，就会盖成高楼，不要畏难，有想法就敲起来吧。 ^_^</li>
</ul>
<hr>
<h2 id="7、控制流程"><a href="#7、控制流程" class="headerlink" title="7、控制流程"></a>7、控制流程</h2><p><img src="https://img.alicdn.com/tfs/TB1B6ODRXXXXXXHaFXXXXXXXXXX-1920-1080.png" alt="控制流程"></p>
<hr>
<h2 id="8、开发"><a href="#8、开发" class="headerlink" title="8、开发"></a>8、开发</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> start<br></code></pre></td></tr></table></figure>
<p>浏览自动打开 <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a></p>
<h3 id="多语言"><a href="#多语言" class="headerlink" title="多语言"></a>多语言</h3><p>在 <a target="_blank" rel="noopener" href="https://github.com/chvin/react-tetris/blob/master/i18n.json">i18n.json</a> 配置多语言环境，使用”lan”参数匹配语言如：<code>https://chvin.github.io/react-tetris/?lan=en</code></p>
<h3 id="打包编译"><a href="#打包编译" class="headerlink" title="打包编译"></a>打包编译</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-built_in">run</span> build<br></code></pre></td></tr></table></figure>

<p>在build文件夹下生成结果。</p>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2024
    VestJin
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     --><!--
       --><li><a href="/games/">Games</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/vestjin">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?571c3612023b230e8c1243489bf880cb";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'cactus-1';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
